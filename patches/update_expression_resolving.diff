diff --git a/django_root/django/db/models/base.py b/django_root/django/db/models/base.py
index 4da2802..676e96f 100644
--- a/django_root/django/db/models/base.py
+++ b/django_root/django/db/models/base.py
@@ -1,5 +1,6 @@
 import types
 import sys
+import operator
 import os
 from itertools import izip
 import django.db.models.manager     # Imported to register signal handler.
@@ -442,12 +443,17 @@ class Model(object):
         Updates specified attributes on the current instance.
         """
         assert self.pk, "Cannot update an instance that has not yet been created."
-        self.__class__._base_manager.using(using).filter(pk=self.pk).update(**kwargs)
-        for k, v in kwargs.iteritems():
+        affected = self.__class__._base_manager.using(using).filter(pk=self.pk).update(**kwargs)
+        for k,v in kwargs.iteritems():
             if isinstance(v, ExpressionNode):
-                # NotImplemented
-                continue
+                v = resolve_expression_node(self, v)
             setattr(self, k, v)
+        if affected == 1:
+            return True
+        elif affected == 0:
+            raise self.DoesNotExist("Cannot update an instance that is not in the database.")
+        else:
+            raise ValueError("Somehow we have updated multiple rows, and you are now royally fucked.")
 
     update.alters_data = True
 
@@ -1004,3 +1010,32 @@ if sys.version_info < (2, 5):
 else:
     def subclass_exception(name, parents, module):
         return type(name, parents, {'__module__': module})
+
+EXPRESSION_NODE_CALLBACKS = {
+    ExpressionNode.ADD: operator.add,
+    ExpressionNode.SUB: operator.sub,
+    ExpressionNode.MUL: operator.mul,
+    ExpressionNode.DIV: operator.div,
+    ExpressionNode.MOD: operator.mod,
+    ExpressionNode.AND: operator.and_,
+    ExpressionNode.OR: operator.or_,
+}
+
+class CannotResolve(Exception):
+    pass
+
+def resolve_expression_node(instance, node):
+    def _resolve(instance, node):
+        if isinstance(node, F):
+            return getattr(instance, node.name)
+        elif isinstance(node, ExpressionNode):
+            return resolve_expression_node(instance, node)
+        return node
+
+    op = EXPRESSION_NODE_CALLBACKS.get(node.connector, None)
+    if not op:
+        raise CannotResolve
+    runner = _resolve(instance, node.children[0])
+    for n in node.children[1:]:
+        runner = op(runner, _resolve(instance, n))
+    return runner
